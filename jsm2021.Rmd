---
title: "Bootstrapping Multilevel Models in R Using `lmeresampler`"
author: "Adam Loy, Carleton College"
date: "[aloy.github.io/jsm2021/jsm2021](https://aloy.github.io/jsm2021/jsm2021)"
header-includes: 
output:
  xaringan::moon_reader:
    css: [jsm.css, useR-fonts]
    lib_dir: libs
    nature:
      highlightStyle: github
      highlightLines: true

---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE, dev = 'svg')

# Loading bib
library(RefManageR)
BibOptions(check.entries = FALSE,
           bib.style = "authoryear",
           cite.style = "authoryear",
           style = "markdown",
           hyperlink = FALSE,
           dashed = FALSE)
myBib <- ReadBib("./lmeresampler_jsm.bib", check = FALSE)
myBib <- sort(myBib)


# Packages
library(readr)
library(ggplot2)
library(dplyr)
library(tidyr)
library(forcats)
library(lme4)
library(HLMdiag)
library(qqplotr)
library(cowplot)
library(lmeresampler)

# Example data set, dropping NAs
osteo <- read_delim("ost phenotypes.dat", delim = "\t") %>%
  select(-contains("X")) %>%
  rename(BMD = `CalL2-L4BMD`) %>%
  mutate(Sex = as_factor(Gender) %>% fct_recode(male = "1", female = "2"), 
         CentreNumber = factor(CentreNumber)) %>%
  filter(Proband == "No") %>%
  drop_na(BMD, Sex, Age, Height, Weight, CentreNumber) %>%
  mutate(Age = Age - mean(Age),
         Height = Height - mean(Height),
         Weight = Weight - mean(Weight))

# Plot theming
theme_useR <- function(base_size = 28) {
  theme_bw(base_size = base_size) + 
    theme(legend.margin = margin(), legend.title = element_blank())
}

# Bootstrap results so that they don't need to be cached
load("jsm_boot_results.RData")

```


## Example

*  Osteoporosis study analyzed by `r Citet(myBib, "galwey2014")` and again by `r Citet(myBib, "Field2010-do")` 

* 2981 subjects recruited from 8 centers

* Bone mineral density (BMD) measured on each subject by an X-ray
scan of the lumbar region 

* Goal is to explore the relationship between BMD and the
sex, age, height, and weight of subjects

* 117 subjects have missing values

???

Before jumping into the bootstrap, let's consider an example where the bootstrap may be useful. 
This example comes from a textbook osteoporosis study analyzed by Galwey. 

There are 2981 subjects in the study who were recruited across 8 centers, so subjects
are nested within centers.

For each subject, Bone mineral density was measured by an X-ray scan of the lumbar region. 

The purpose of Galwey's analysis was to explore the relationship 
between Bone mineral density and the sex, age, height, and weight of the subjects.

117 cases had missing values on at least one of the predictors, so those cases were dropped for
simplicity.

---

## Initial mixed-effects model


`r Citet(myBib, "galwey2014")` propose this initial model

```{r galwey model}
fm <- lmer(BMD ~ Sex + Age + I(Age^2) + Height*Weight + 
             I(Height^2) + I(Weight^2) + (1|CentreNumber), 
           data = osteo)
```

* Fixed effects Sex, Age, Age<sup>2</sup>, Height, Height<sup>2</sup>, and Height $\times$ Weight

* Random intercept for CentreNumber

???

The initial model considered by Galwey included sex, linear and quadratic terms for age, height, and weight,
as well as the interaction between height and weight as predictors, and included a random intercept for the center number.

This model is easily fit via lmer in the lme4 R package.

---

## Conditional residuals

```{r galwey diagnostics, echo=FALSE, message=FALSE, fig.height = 3, fig.width = 9, out.width="100%", fig.show="hold", fig.alt ="Three residual plots. The left plot displays a histogram of the conditional residuals and is right skewed with some high outliers. The middle plot is a scatterplot of the conditional residuals plotted against the conditional fitted values. The largest conditional residuals do not stand out in terms of the fitted values. The rightmost plot is a normal Q-Q plot of the conditional residuals. The right skew and outliers are again evident."}
fm_resids <- hlm_resid(fm, standardize = FALSE, include.ls = FALSE)

dp1 <- 
  ggplot(data = fm_resids, aes(x = .resid)) + 
  geom_histogram() +
  labs(x = "Conditional residuals", y = "Frequency") +
  theme_minimal_grid()

dp2 <- 
  ggplot(data = fm_resids, aes(x = .fitted, y = .resid)) + 
  geom_point(alpha = 0.3) +
  labs(y = "Conditional residuals", x = "Conditional fitted values") +
  theme_minimal_grid()

dp3 <- ggplot(data = fm_resids, aes(sample = .resid)) +
  stat_qq_band(fill = "steelblue", alpha = 0.5) +
  stat_qq_line(color = "steelblue") +
  stat_qq_point() +
  labs(x = "Normal quantiles", y = "Conditional residuals") +
  theme_minimal_grid()
  
plot_grid(dp1, dp2, dp3, nrow = 1)
```

* Analysis of the conditional residuals reveals a violation of $\varepsilon \sim \mathcal{N}(\mathbf{0}, \sigma^2 \mathbf{I})$

* `r Citet(myBib, "galwey2014")` deletes 63 outliers identified from more extensive scans

???

After fitting the initial model, Galwey conducted a brief residual analysis and noted the 
apparent non-normality of the conditional residuals. The skew of the residual distribution can be seed in both the histogram and the normal Q-Q plot.

To address this issue, Galwey deleted 63 outliers that were identified by more extensive scanning methods; however there is another option.

While the model seems suspect due to a distributional violation or
contamination with outliers, more robust analysis is possible using methods such as the bootstrap.

Throughout this talk I'll guide you through how to implement bootstrap procedures for linear mixed-effects 
models in R, and also point to some additional applications.

---

## Bootstrapping LME models in R

```{r include=FALSE}
NoCite(myBib, "Van_der_Leeden2008")
```


- 2008 van der Leeden, Meijer, and Busing point out that R users must implement their own bootstrap procedures

- 2009 useR! talk by Sánchez-Espigares & Ocaña outlined a framework
    + parametric
    + semiparametric
    + Wild
    + semiparametric by block

- 2013 `lme4::bootMer()` implemented parametric bootstrap, semiparametric added later

???

In 2008, Van der Leeden and coauthors pointed out that many bootstrap procedures were unavailable in R, so users needed to program their own bootstraps if they wanted something other than the parametric. 

In 2009, an R package was presented at useR! outlining a comprehensive framework for bootstrapping multilevel models. Unfortunately, the package never made it's way to CRAN and the project appears to have been abandoned. 

Since that time, there have been a few additions to `lme4` in terms of bootstrapping capabilities, but numerous procedures are still missing. lmeresampler implements many of the missing procedures and is under active maintenance and development.

---

## lmeresampler

Implements a wider set of bootstrap algorithms available to `nlme` and `lme4` users

- parametric*

- residual (semi-parametric)*

- cases (non-parametric)*

- random-effects block

- wild

<br>

<br>

<br>

`*` = Also works with model fit via `lme4::glmer()`


???

lmeresampler provides users with easy access to a larger set of bootstrap procedures for models fit using lme in the nlme package or lmer in the lme4 package. 

Currently, it implements five procedures for Gaussian response models, including the parametric, 
residual, cases, random-effects block, and wild bootstraps. 

The parametric, residual, and cases bootstraps are also available for generalized linear mixed-effects  models fit via `glmer`.
  

---

## Residual bootstrap

`r Citet(myBib, "Carpenter2003")` proposed a residual bootstrap for multilevel models

1. Fit the model via `lme4::lmer()` or `nlme::lme()`

2. Extract the error terms and random effects.

3. Mean-center and "reflate" them, so that the empirical covariance matrices of these residual quantities match the estimated covariance matrices prior to resampling.

4. Resample from the each residual quantity and generate bootstrap responses.

5. Refit the model and extract the quantities of interest.

6. Repeat 3-5 B times.

???

In our example, if we question the distributional assumption placed on the conditional residuals, then a robust alternative to typical parametric inference is the residual bootstrap proposed by Carpenter, Goldstein and Rasbash. 

The bootstrap procedure is similar to the residual bootstrap from classical regression, but there are two types of residuals: conditional residuals (sometimes called error terms) and random effects. 

In addition, before resampling the residual quantities, we center and reflate them. Carpenter et al. termed "reflation" as the adjustment made to the residuals to ensure the empirical covariance matrices match the estimated covariance matrices.

---

## Example

Implementing a residual bootstrap for Galwey's initial model

```{r eval=FALSE}
resid_boot <- bootstrap(
  fm,                 # lme4/nlme output 
  .f = fixef,         # user-specified function
  type = "residual",  # bootstrap algorithm
  B = 15000           # No. resamples
)
```

???

The residual bootstrap can be implemented for our fitted model, stored in the fm object, using the bootstrap() command. bootstrap() provides a unified interface to all of the bootstrap procedures implemented in lmeresampler.

---


## Example

Implementing a residual bootstrap for Galwey's initial model

```{r eval=FALSE}
resid_boot <- bootstrap(
* fm,                 # lme4/nlme output 
  .f = fixef,         # user-specified function
  type = "residual",  # bootstrap algorithm
  B = 15000           # No. resamples
)
```

???

The first argument to bootstrap is our fitted model, which is stored in `fm` in this example.

---

## Example

Implementing a residual bootstrap for Galwey's initial model

```{r eval=FALSE}
resid_boot <- bootstrap(
  fm,                 # lme4/nlme output 
* .f = fixef,         # user-specified function
  type = "residual",  # bootstrap algorithm
  B = 15000           # No. resamples
)
```

???

Next, we specify `.f`, a function calculating the quantities of interest from each bootstrap iteration. In this example, we're calculating the fixed effects, but any function calculating or extracting quantities from the fitted model works.

---

## Example

Implementing a residual bootstrap for Galwey's initial model

```{r eval=FALSE}
resid_boot <- bootstrap(
  fm,                 # lme4/nlme output 
  .f = fixef,         # user-specified function
* type = "residual",  # bootstrap algorithm
  B = 15000           # No. resamples
)
```

???

To specify the bootstrap procedure, set the type argument. Here we set type equal to residual.


---

## Example

Implementing a residual bootstrap for Galwey's initial model

```{r eval=FALSE}
resid_boot <- bootstrap(
  fm,                 # lme4/nlme output 
  .f = fixef,         # user-specified function
  type = "residual",  # bootstrap algorithm
* B = 15000           # No. resamples
)
```

???

Finally,  set the number of bootstrap iterations, B. In this example, we set B equal to 15K, which is in line with Tim Hesterberg's suggestions.

---

## Summary

```{r}
summary(resid_boot)
```

???

bootstrap returns an object of class lmeresamp, and we've provided familiar methods to explore the results. For example, the summary function allows us to quickly explore the mean, standard error, and bias of our results. It also informs us of any warnings encountered along the way, such as boundary or convergence issues. 



---

## Confidence intervals

```{r}
confint(resid_boot, type = "basic", level = 0.89)
```

`type = "norm"` or `"perc"` also implemented


???

The confint function provides normal, basic, and percentile bootstrap confidence intervals for all terms by default. 

In this example, we calculate only basic bootstrap intervals by setting type equal to "basic". 

---

## Plots

Halfeye plots are produced via `ggdist` `r Citet(myBib, "ggdist")`


```{r echo=TRUE, fig.height = 3, fig.width = 3, fig.show='hold', fig.alt = "Two half-eye plots, the left plot shows the boostrap distribution of the coeffecient for age, the right plots shows the bootstrap distribution for age squared."}
plot(resid_boot, var = "Age")
plot(resid_boot, var = 4)
```


???

You can create plots of the bootstrap distributions for each quantity using the plot() command. Here, we have half-eye plots displaying the bootstrap distributions for the age and age^2 terms.

Halfeye plots are produced using the ggdist package. A half-eye plot consists of a density plot with central intervals highlighted below. The central 66% and 95% percentile intervals are displayed by default.

If the var argument is not specified, distributions of all the terms are rendered, which can be difficult to read if they are on different scales. 

To specify a single term, you can set var equal to the name of the term, as seen here when plotting age. 

Alternatively, you can use a numeric index to specify var, as seen here where we set var equal to 4 to plot the distribution for age^2.


---

## `lmeresamp` objects

```{r}
names(resid_boot)
```

???

An lmeresamp object is just a named list, so it's easy to access specific components. 


--

Extract the bootstrap statistics

```{r eval=FALSE}
resid_boot$replicates
```
```{r echo=FALSE}
print(resid_boot$replicates, n = 5, width = 70)
```

???

You will most commonly want to access the replicates element, which store the bootstrap statistics or replicates. If you see errors, warnings, or messages, then you might want to look into these elements, which provide lists of the raw messages. This will help you decide whether you need to exclude any replicates.



---

## Speeding things up

You can easily utilize parallel processing to speed up the computation via `foreach`

```{r eval=FALSE}
library(foreach)
library(doParallel)

no_cores <- 5
cl <- makeCluster(no_cores, type = "FORK")
registerDoParallel(cores = no_cores)

boot_parallel <- foreach(
  B = rep(3000, 5), 
  .combine = combine_lmeresamp) %dopar% {
    bootstrap(fm, .f = fixef, type = "residual", B = B)
  }
stopCluster(cl)
```

???

Bootstrapping is a computationally demanding task, but is easily run in parallel since each iteration of the bootstrap requires no interaction with other iterations. We did not implement parallel processing within lmeresampler, rather we provide the combine_lmeresamp function so that the user can implement parallelization via the foreach package. This provides flexibility to the user, allowing them to choose the type of cluster based on their situation and hardware setup.

---

## Speeding things up

You can easily utilize parallel processing to speed up the computation via `foreach`

```{r eval=FALSE}
library(foreach)
library(doParallel)

no_cores <- 5 #<<
cl <- makeCluster(no_cores, type = "FORK") #<<
registerDoParallel(cores = no_cores) #<<

boot_parallel <- foreach(
  B = rep(3000, 5), 
  .combine = combine_lmeresamp) %dopar% {
    bootstrap(fm, .f = fixef, type = "residual", B = B)
  }
stopCluster(cl)
```

???
In this example, I'm using a small fork cluster with five cores. 

---

## Speeding things up

You can easily utilize parallel processing to speed up the computation via `foreach`

```{r eval=FALSE}
library(foreach)
library(doParallel)

no_cores <- 5
cl <- makeCluster(no_cores, type = "FORK") 
registerDoParallel(cores = no_cores) 

boot_parallel <- foreach(
  B = rep(3000, 5), #<<
  .combine = combine_lmeresamp) %dopar% {
    bootstrap(fm, .f = fixef, type = "residual", B = B)
  }
stopCluster(cl)
```

???
Within the foreach call, I specify that B = 3000 replicates should be run on each of the five cores.


---

## Speeding things up

You can easily utilize parallel processing to speed up the computation via `foreach`

```{r eval=FALSE}
library(foreach)
library(doParallel)

no_cores <- 5
cl <- makeCluster(no_cores, type = "FORK") 
registerDoParallel(cores = no_cores) 

boot_parallel <- foreach(
  B = rep(3000, 5), 
  .combine = combine_lmeresamp) %dopar% { #<<
    bootstrap(fm, .f = fixef, type = "residual", B = B) #<<
  } #<<
stopCluster(cl)
```

???

Then, the combine_lmeresamp() function should be used to combine the results. I then use the dopar operator to call the bootstrap command we discussed previously.

--

.pull-left[
Sequential runtime
```{r echo=FALSE}
stime
```

]

.pull-right[
Parallel runtime
```{r echo=FALSE}
ptime
```

]



???

On my laptop, the runtime decreased by a factor of about `r round(stime[3] / ptime[3], 1)`. 


---

## Unified framework

In `bootstrap()`, change `type` and set additional parameters to run a different procedure


Example: Case bootstrap example, resampling only the subjects within centers

```{r eval=FALSE}
case_boot <- bootstrap(fm, .f = fixef, type = "case", 
                       B = 15000, resample = c(FALSE, TRUE)
                       )
```

???

So far, we've only used the residual bootstrap, but other procedures are easily implemented by changing the type and passing in any required arguments. 

For example, if we wished to utilize the non-parametric cases bootstrap, we set type equal to case, and need to specify a resample argument. The resample argument requires a logical vector specifying which levels of the model should be resampled, starting with the topmost level. Here we set resample to FALSE, TRUE, indicating that we should not resample the groups, but should resample subjects within groups.

--

|Bootstrap $\qquad$   | Type  $\qquad$       | Required arguments|
|:---------------|:-------------------|:-----------|
|Cases      | `"case"`       | `model, .f, type, B, resample`|
|Residual   | `"residual"`   | `model, .f, type, B`|
|REB        | `"reb"`        | `model, .f, type, B, reb_type`|
|Wild       | `"wild"`       | `model, .f, type, B, hccme, aux.dist`|
|Parametric | `"parametric"` | `model, .f, type, B`|


???

Here is a table providing the required arguments for each type of bootstrap. More details can be found in the help file.

---

## Simulation-based diagnostics

`r Citet(myBib, "Loy2017")` recommends using lineups to visually diagnose LME models

.pull-left[
* Plot residuals vs. fitted values/predictor/group index

* .bold[Generate decoy (null) data sets where we know the model assumptions are upheld]

* Make plots of the decoy data sets

* Render the lineup via faceting
]

.pull-right[
```{r include=FALSE}
set.seed(62758)
```

```{r lineup, eval = FALSE, echo=FALSE, cache=TRUE, fig.height = 6, fig.width = 7.5, message=FALSE, out.width="120%"}
library(HLMdiag) # easy residual extraction
library(nullabor) # easy lineup data wrangling
decoy_resids <- bootstrap(fm, .f = hlm_resid, type = "parametric", B = 19)
lineup_data  <- lineup(true = hlm_resid(fm), n = 19, samples = decoy_resids$replicates) 

ggplot(data = lineup_data, aes(x = .fitted, y = .resid)) + 
  geom_point(alpha = 0.15) +
  labs(y = "Conditional residuals", x = "Conditional fitted values") +
  facet_wrap(~.sample) +
  theme_bw()

height <- 4.5
ggsave("lineup.jpg", width = 1.25 * height, height = height)
```

```{r, out.width="120%", echo=FALSE, fig.alt = "A lineup of residual plots rendered from Galeway's model. 19 panels display decoy residuals generated from a parametric bootstrap. The true residuals are embedded in the lineup in pael 7 and appear different from the decoys, indicating a potential model deficiency."}
knitr::include_graphics("lineup.jpg")
```


]

???

Now that you have seen the basic of what lmeresampler can do, let's look at another example. In my 2017 paper with Heike Hofmann and Di Cook, we recommend using lineups of residual plots to diagnose linear mixed-effects models. 

To construct a lineup, we need to identify and create a diagnostic plot of interest, simulate decoy data sets where we know the model assumptions are upheld, generate plots from these decoy data sets, and finally render the lineup through faceting.

An example lineup is displayed for Galwey's original model here. 19 panels display decoy residuals generated from a parametric bootstrap. The true residuals are embedded in the lineup in panel 7 and appear different from the decoys, indicating a potential model deficiency.

Prior to lmeresampler, creating this type of lineup was a bit tedious.

---

Load helper packages for lineups
```{r eval=FALSE}
library(HLMdiag) # easy residual extraction
library(nullabor) # easy lineup data wrangling
```

???

Let's walk through how to construct such a lineup. I'll pull in additional diagnostic tools from the HLMdiag package, and a data wrangling function from the nullabor package.

--

Generate "decoy data" via parametric bootstrap
```{r true=FALSE, cache=TRUE}
decoys <- bootstrap(fm, .f = hlm_resid, type = "parametric", B = 19)
```

???

The parametric bootstrap can be used to generate decoy data via the bootstrap function. Here we generate 19 decoy data sets, since we want to create a lineup with 20 facets. Notice that we extract the hlm residuals for each bootstrap replicate.

--

Randomly embed real residual data into the field of decoys
```{r true=FALSE, cache=TRUE}
lineup_data <- lineup(true = hlm_resid(fm), n = 19, 
                      samples = decoys$replicates) 
```

???

Next, we combine and format the true residuals extract from fm with the decoy residuals obtained from the bootstrap using nullabor's lineup function. The observed residuals from our fitted model are passed to the true argument, and the residuals from the bootstrapped models are passed to the samples argument. Notice that these residuals are stored in the replicates element of the decoys object.

The lineup function prints a coded message with the location of the true panel, so you don't have to guess if it's hard to discern. To decode this message, simply copy and paste this decrypt command into your console.


---

Create a faceted scatterplot
```{r eval=FALSE}
ggplot(data = lineup_data, aes(x = .fitted, y = .resid)) + 
  geom_point(alpha = 0.25) +
  labs(y = "Conditional residuals", x = "Conditional fitted values") +
  facet_wrap(~.sample) +
  theme_bw()
```

```{r, out.width="75%", echo=FALSE, fig.alt = "A lineup of residual plots rendered from Galeway's model. 19 panels display decoy residuals generated from a parametric bootstrap. The true residuals are embedded in the lineup in pael 7 and appear different from the decoys, indicating a potential model deficiency.", fig.align='center'}
knitr::include_graphics("lineup.jpg")
```

???

Finally, we can use typical ggplot2 code to render the faceted scatterplot.

As we saw before, the residuals from the fitted model stand out, making us question the model's adequacy.

---

### Get the package

Stable version on CRAN
```{r eval=FALSE}
install.packages("lmeresampler")
```

Development version on GitHub
```{r eval=FALSE}
remotes::install_github("aloy/lmeresampler")
```

???

Thanks for watching my extended presentation! If you want to install lmeresampler and explore its functionality, you can obtain the stable version from CRAN or download the development version from GitHub. 

--

### Read about the package

Documentation and examples: https://aloy.github.io/lmeresampler/

Read the preprint: https://arxiv.org/a/loy_a_1.html

???

You can also find documentation on the lmeresampler GitHub page, and can read a preprint detailing the functionality and a few additional use cases on the arxiv.


---

#### References

```{r echo=FALSE, results='asis'}
print(myBib[1:5])
```

---

#### References

```{r echo=FALSE, results='asis'}
print(myBib[6:7])
```